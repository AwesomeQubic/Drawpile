/* automatically generated by rust-bindgen 0.60.1 */

pub const MYPAINT_TILE_SIZE: u32 = 64;
pub const MYPAINT_MAX_THREADS: u32 = 16;
pub const MYPAINT_MAX_MIPMAP_LEVEL: u32 = 4;
pub const FALSE: u32 = 0;
extern "C" {
    #[doc = " If libmypaint is built with OpenMP support, this call ensures"]
    #[doc = " that no more than #MYPAINT_MAX_THREADS will be used. If libmypaint"]
    #[doc = " is _not_ built with OpenMP support, calling this is a no-op."]
    pub fn mypaint_init();
}
pub type gpointer = *mut ::std::os::raw::c_void;
pub type gchar = ::std::os::raw::c_char;
pub type gint = ::std::os::raw::c_int;
pub type gboolean = gint;
pub type guint16 = ::std::os::raw::c_ushort;
#[doc = " Representation of a rectangle, integer values: (x, y, w, h)"]
#[doc = ""]
#[doc = " Rectangles are only used for registering areas that have been affected"]
#[doc = " by brush strokes - the units of the parameters are pixels."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MyPaintRectangle {
    #[doc = " The x-coordinate of the rectangle's top-left corner"]
    pub x: ::std::os::raw::c_int,
    #[doc = " The x-coordinate of the rectangle's top-left corner"]
    pub y: ::std::os::raw::c_int,
    #[doc = " The width of the rectangle"]
    pub width: ::std::os::raw::c_int,
    #[doc = " The height of the rectangle"]
    pub height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_MyPaintRectangle() {
    assert_eq!(
        ::std::mem::size_of::<MyPaintRectangle>(),
        16usize,
        concat!("Size of: ", stringify!(MyPaintRectangle))
    );
    assert_eq!(
        ::std::mem::align_of::<MyPaintRectangle>(),
        4usize,
        concat!("Alignment of ", stringify!(MyPaintRectangle))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<MyPaintRectangle>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(MyPaintRectangle),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<MyPaintRectangle>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(MyPaintRectangle),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<MyPaintRectangle>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(MyPaintRectangle),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<MyPaintRectangle>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(MyPaintRectangle),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
}
#[doc = " Holds the size and location of a MyPaintRectangle array."]
#[doc = ""]
#[doc = " Only used in the MyPaintSurface2 interface for handling multiple"]
#[doc = " areas affected by a stroke (only _actually_ used in"]
#[doc = " MyPaintTiledSurface2, which implements MyPaintSurface2)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MyPaintRectangles {
    #[doc = " The number of rectangles"]
    #[doc = ""]
    #[doc = " The number of rectangles that the space pointed"]
    #[doc = " to by MyPaintRectangles::rectangles can fit."]
    pub num_rectangles: ::std::os::raw::c_int,
    #[doc = " Pointer to a single, or an array of, MyPaintRectangle%s"]
    #[doc = ""]
    #[doc = " The space pointed to should fit at least n MyPaintRectangle%s,"]
    #[doc = " where n = MyPaintRectangles::num_rectangles"]
    pub rectangles: *mut MyPaintRectangle,
}
#[test]
fn bindgen_test_layout_MyPaintRectangles() {
    assert_eq!(
        ::std::mem::size_of::<MyPaintRectangles>(),
        16usize,
        concat!("Size of: ", stringify!(MyPaintRectangles))
    );
    assert_eq!(
        ::std::mem::align_of::<MyPaintRectangles>(),
        8usize,
        concat!("Alignment of ", stringify!(MyPaintRectangles))
    );
    fn test_field_num_rectangles() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<MyPaintRectangles>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_rectangles) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(MyPaintRectangles),
                "::",
                stringify!(num_rectangles)
            )
        );
    }
    test_field_num_rectangles();
    fn test_field_rectangles() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<MyPaintRectangles>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rectangles) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(MyPaintRectangles),
                "::",
                stringify!(rectangles)
            )
        );
    }
    test_field_rectangles();
}
extern "C" {
    #[doc = " Minimally expand a rectangle so that it contains a given point (x, y)."]
    #[doc = ""]
    #[doc = " @param[out] r The rectangle that may be expanded"]
    #[doc = " @param x, y The coordinates of the point to expand to"]
    #[doc = ""]
    #[doc = " If the point (__x__, __y__) lies outside of the given rectangle"]
    #[doc = " pointed to by  __r__, the rectangle is expanded the minimum amount"]
    #[doc = " needed for the point to lie within its new boundaries."]
    #[doc = ""]
    #[doc = " @memberof MyPaintRectangle"]
    pub fn mypaint_rectangle_expand_to_include_point(
        r: *mut MyPaintRectangle,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Minimally expand a rectangle so that it fully contains another"]
    #[doc = ""]
    #[doc = " @param[out] r The rectangle that may be expanded"]
    #[doc = " @param other The rectangle to expand __r__ to"]
    #[doc = ""]
    #[doc = " If __r__ does not completely contain __other__, __r__ is expanded the minimum"]
    #[doc = " amount needed for __other__ to lie fully within __r__'s boundaries."]
    #[doc = ""]
    #[doc = " @memberof MyPaintRectangle"]
    pub fn mypaint_rectangle_expand_to_include_rect(
        r: *mut MyPaintRectangle,
        other: *mut MyPaintRectangle,
    );
}
extern "C" {
    #[doc = " Create a copy of the given rectangle."]
    #[doc = ""]
    #[doc = " Allocates a new MyPaintRectangle, copies the input rectangle"]
    #[doc = " to it, and returns its address."]
    #[doc = " If the allocation fails, __NULL__ is returned."]
    #[doc = ""]
    #[doc = " @param r A pointer to the rectangle to copy."]
    #[doc = " @returns A pointer to a new copy of __r__, or __NULL__."]
    #[doc = ""]
    #[doc = " @memberof MyPaintRectangle"]
    pub fn mypaint_rectangle_copy(r: *mut MyPaintRectangle) -> *mut MyPaintRectangle;
}
#[doc = " Function used to retrieve the average color/alpha from a region of a surface."]
#[doc = ""]
#[doc = " This kind of function calculates the average color/alpha from the pixels"]
#[doc = " of the given surface, selected and weighted respectively by the area"]
#[doc = " and opacity of a uniform dab with a given center and radius."]
#[doc = ""]
#[doc = " @param self The surface to fetch the pixels from"]
#[doc = " @param x, y The center of the dab that determine which pixels"]
#[doc = " to include, and their respective impact on the result."]
#[doc = " @param radius The radius of the dab."]
#[doc = " @param[out] color_r, color_g, color_b, color_a"]
#[doc = " The destination of the resulting colors, range: [0.0, 1.0]"]
pub type MyPaintSurfaceGetColorFunction = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *mut MyPaintSurface,
        x: f32,
        y: f32,
        radius: f32,
        color_r: *mut f32,
        color_g: *mut f32,
        color_b: *mut f32,
        color_a: *mut f32,
    ),
>;
#[doc = " Function used to draw a dab with the given properties on the surface."]
#[doc = ""]
#[doc = " The function drawing the dab is one of the core parts of any surface"]
#[doc = " implementation. These functions will usually not be invoked directly"]
#[doc = " by library users, but indirectly as part of the ::mypaint_brush_stroke_to"]
#[doc = " call, where the interpolated parameters for each dab are calculated."]
#[doc = ""]
#[doc = " @param self The surface on which the dab will be drawn"]
#[doc = " @param x, y The center of the dab"]
#[doc = " @param radius The radius of the dab"]
#[doc = " @param color_r, color_g, color_b, opaque color/opacity of the dab"]
#[doc = " @param hardness Determines how opacity is retained for"]
#[doc = " pixels further from the dab center."]
#[doc = " @param alpha_eraser Hell if I know"]
#[doc = " @param aspect_ratio The width/height ratio of the dab."]
#[doc = " @param angle The angle of the dab (applied after __aspect_ratio__)."]
#[doc = " @param lock_alpha The extent to which the alpha values of affected pixels"]
#[doc = " on the surface are retained, regardless of other dab parameters."]
#[doc = " @param colorize: The extent to which the dab will __only__ affect the hue of"]
#[doc = " existing pixels on the surface."]
#[doc = ""]
#[doc = " @memberof MyPaintSurface"]
pub type MyPaintSurfaceDrawDabFunction = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *mut MyPaintSurface,
        x: f32,
        y: f32,
        radius: f32,
        color_r: f32,
        color_g: f32,
        color_b: f32,
        opaque: f32,
        hardness: f32,
        alpha_eraser: f32,
        aspect_ratio: f32,
        angle: f32,
        lock_alpha: f32,
        colorize: f32,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Destructor for surface implementations."]
#[doc = " @param self The surface to free/destroy"]
#[doc = ""]
#[doc = " @memberof MyPaintSurface"]
pub type MyPaintSurfaceDestroyFunction =
    ::std::option::Option<unsafe extern "C" fn(self_: *mut MyPaintSurface)>;
#[doc = " Function for rendering a png file from a surface."]
#[doc = " @param self The surface to render from"]
#[doc = " @param path The destination of the png file"]
#[doc = " @param x, y The top left corner of the area to export"]
#[doc = " @param width, height The dimensions of the area & of the resulting png"]
#[doc = ""]
#[doc = " @memberof MyPaintSurface"]
pub type MyPaintSurfaceSavePngFunction = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *mut MyPaintSurface,
        path: *const ::std::os::raw::c_char,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ),
>;
#[doc = " Prepare the surface for an atomic set of stroke operations."]
#[doc = ""]
#[doc = " Each call to functions of this type should be matched by a call to a"]
#[doc = " ::MyPaintSurfaceEndAtomicFunction with the same surface."]
#[doc = ""]
#[doc = " @memberof MyPaintSurface"]
pub type MyPaintSurfaceBeginAtomicFunction =
    ::std::option::Option<unsafe extern "C" fn(self_: *mut MyPaintSurface)>;
#[doc = " Finalize an atomic set of stroke operations, setting an invalidation rectangle."]
#[doc = ""]
#[doc = " Each call to functions of this type should be matched by a call to a"]
#[doc = " ::MyPaintSurfaceBeginAtomicFunction with the same surface."]
#[doc = ""]
#[doc = " @memberof MyPaintSurface"]
pub type MyPaintSurfaceEndAtomicFunction = ::std::option::Option<
    unsafe extern "C" fn(self_: *mut MyPaintSurface, roi: *mut MyPaintRectangle),
>;
#[doc = " Abstract surface type for the MyPaint brush engine. The surface interface"]
#[doc = " lets the brush engine specify dabs to render, and get color data for use"]
#[doc = " in interpolations."]
#[doc = ""]
#[doc = " @sa MyPaintSurface2"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MyPaintSurface {
    #[doc = " Function for drawing a dab on the surface."]
    #[doc = ""]
    #[doc = " See ::MyPaintSurfaceDrawDabFunction for details."]
    pub draw_dab: MyPaintSurfaceDrawDabFunction,
    #[doc = " Function for retrieving color data from the surface."]
    #[doc = ""]
    #[doc = " See ::MyPaintSurfaceGetColorFunction for details."]
    pub get_color: MyPaintSurfaceGetColorFunction,
    #[doc = " Prepare the surface for a set of atomic stroke/dab operations."]
    #[doc = ""]
    #[doc = " See ::MyPaintSurfaceBeginAtomicFunction for details."]
    pub begin_atomic: MyPaintSurfaceBeginAtomicFunction,
    #[doc = " Finalize the operations run after a call to #begin_atomic."]
    #[doc = ""]
    #[doc = " See ::MyPaintSurfaceEndAtomicFunction for details."]
    pub end_atomic: MyPaintSurfaceEndAtomicFunction,
    #[doc = " Destroy the surface (free up all allocated resources)."]
    pub destroy: MyPaintSurfaceDestroyFunction,
    #[doc = " Save a region of the surface to a png file."]
    #[doc = ""]
    #[doc = " See MyPaintSurfaceSavePngFunction for details"]
    pub save_png: MyPaintSurfaceSavePngFunction,
    #[doc = " Reference count - number of references to the struct"]
    #[doc = ""]
    #[doc = " This is only useful when used in a context with automatic"]
    #[doc = " memory management and can be ignored if construction/destruction"]
    #[doc = " is handled manually."]
    pub refcount: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_MyPaintSurface() {
    assert_eq!(
        ::std::mem::size_of::<MyPaintSurface>(),
        56usize,
        concat!("Size of: ", stringify!(MyPaintSurface))
    );
    assert_eq!(
        ::std::mem::align_of::<MyPaintSurface>(),
        8usize,
        concat!("Alignment of ", stringify!(MyPaintSurface))
    );
    fn test_field_draw_dab() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<MyPaintSurface>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).draw_dab) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(MyPaintSurface),
                "::",
                stringify!(draw_dab)
            )
        );
    }
    test_field_draw_dab();
    fn test_field_get_color() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<MyPaintSurface>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_color) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(MyPaintSurface),
                "::",
                stringify!(get_color)
            )
        );
    }
    test_field_get_color();
    fn test_field_begin_atomic() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<MyPaintSurface>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).begin_atomic) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(MyPaintSurface),
                "::",
                stringify!(begin_atomic)
            )
        );
    }
    test_field_begin_atomic();
    fn test_field_end_atomic() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<MyPaintSurface>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).end_atomic) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(MyPaintSurface),
                "::",
                stringify!(end_atomic)
            )
        );
    }
    test_field_end_atomic();
    fn test_field_destroy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<MyPaintSurface>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(MyPaintSurface),
                "::",
                stringify!(destroy)
            )
        );
    }
    test_field_destroy();
    fn test_field_save_png() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<MyPaintSurface>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).save_png) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(MyPaintSurface),
                "::",
                stringify!(save_png)
            )
        );
    }
    test_field_save_png();
    fn test_field_refcount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<MyPaintSurface>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).refcount) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(MyPaintSurface),
                "::",
                stringify!(refcount)
            )
        );
    }
    test_field_refcount();
}
extern "C" {
    #[doc = " Invoke MyPaintSurface::draw_dab"]
    #[doc = ""]
    #[doc = " @memberof MyPaintSurface"]
    #[doc = " @sa MyPaintSurfaceDrawDabFunction"]
    pub fn mypaint_surface_draw_dab(
        self_: *mut MyPaintSurface,
        x: f32,
        y: f32,
        radius: f32,
        color_r: f32,
        color_g: f32,
        color_b: f32,
        opaque: f32,
        hardness: f32,
        alpha_eraser: f32,
        aspect_ratio: f32,
        angle: f32,
        lock_alpha: f32,
        colorize: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Invoke MyPaintSurface::get_color"]
    #[doc = ""]
    #[doc = " @memberof MyPaintSurface"]
    #[doc = " @sa MyPaintSurfaceGetColorFunction"]
    pub fn mypaint_surface_get_color(
        self_: *mut MyPaintSurface,
        x: f32,
        y: f32,
        radius: f32,
        color_r: *mut f32,
        color_g: *mut f32,
        color_b: *mut f32,
        color_a: *mut f32,
    );
}
extern "C" {
    #[doc = " Invoke MyPaintSurface::get_color and return the alpha component"]
    #[doc = ""]
    #[doc = " @memberof MyPaintSurface"]
    #[doc = " @sa MyPaintSurfaceGetColorFunction"]
    pub fn mypaint_surface_get_alpha(
        self_: *mut MyPaintSurface,
        x: f32,
        y: f32,
        radius: f32,
    ) -> f32;
}
extern "C" {
    #[doc = " Invoke MyPaintSurface::save_png"]
    #[doc = ""]
    #[doc = " @memberof MyPaintSurface"]
    #[doc = " @sa MyPaintSurfaceSavePngFunction"]
    pub fn mypaint_surface_save_png(
        self_: *mut MyPaintSurface,
        path: *const ::std::os::raw::c_char,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Invoke MyPaintSurface::begin_atomic"]
    #[doc = ""]
    #[doc = " @memberof MyPaintSurface"]
    #[doc = " @sa MyPaintSurfaceBeginAtomicFunction"]
    pub fn mypaint_surface_begin_atomic(self_: *mut MyPaintSurface);
}
extern "C" {
    #[doc = " Invoke MyPaintSurface::begin_atomic"]
    #[doc = ""]
    #[doc = " @memberof MyPaintSurface"]
    #[doc = " @sa MyPaintSurfaceBeginAtomicFunction"]
    pub fn mypaint_surface_end_atomic(self_: *mut MyPaintSurface, roi: *mut MyPaintRectangle);
}
extern "C" {
    #[doc = " Set #refcount to 1"]
    #[doc = ""]
    #[doc = " @memberof MyPaintSurface"]
    pub fn mypaint_surface_init(self_: *mut MyPaintSurface);
}
extern "C" {
    #[doc = " Increase #refcount by 1"]
    #[doc = ""]
    #[doc = " @memberof MyPaintSurface"]
    pub fn mypaint_surface_ref(self_: *mut MyPaintSurface);
}
extern "C" {
    #[doc = " Decrease #refcount by 1 and call #destroy if it reaches 0"]
    #[doc = ""]
    #[doc = " @memberof MyPaintSurface"]
    pub fn mypaint_surface_unref(self_: *mut MyPaintSurface);
}
#[doc = " Like #MyPaintSurfaceDrawDabFunction, but supporting posterization and spectral mixing"]
#[doc = ""]
#[doc = " @param posterize Posterization factor"]
#[doc = " @param posterize_num Number of posterization levels"]
#[doc = " @param paint Spectral mixing factor"]
#[doc = ""]
#[doc = " @sa MyPaintSurfaceDrawDabFunction"]
#[doc = " @memberof MyPaintSurface2"]
pub type MyPaintSurfaceDrawDabFunction2 = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *mut MyPaintSurface2,
        x: f32,
        y: f32,
        radius: f32,
        color_r: f32,
        color_g: f32,
        color_b: f32,
        opaque: f32,
        hardness: f32,
        alpha_eraser: f32,
        aspect_ratio: f32,
        angle: f32,
        lock_alpha: f32,
        colorize: f32,
        posterize: f32,
        posterize_num: f32,
        paint: f32,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Like #MyPaintSurfaceGetColorFunction, but for spectral colors."]
#[doc = ""]
#[doc = " @param paint Spectral mixing factor."]
#[doc = " To what extent spectral weighting will be used in place of straight averaging."]
#[doc = " Input value range: [0.0, 1.0]"]
#[doc = ""]
#[doc = " @sa MyPaintSurfaceGetColorFunction"]
#[doc = " @memberof MyPaintSurface2"]
pub type MyPaintSurfaceGetColorFunction2 = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *mut MyPaintSurface2,
        x: f32,
        y: f32,
        radius: f32,
        color_r: *mut f32,
        color_g: *mut f32,
        color_b: *mut f32,
        color_a: *mut f32,
        paint: f32,
    ),
>;
#[doc = " Like #MyPaintSurfaceEndAtomicFunction, but with support for multiple invalidation rectangles."]
#[doc = ""]
#[doc = " @sa MyPaintSurfaceEndAtomicFunction"]
#[doc = " @memberof MyPaintSurface2"]
pub type MyPaintSurfaceEndAtomicFunction2 = ::std::option::Option<
    unsafe extern "C" fn(self_: *mut MyPaintSurface2, roi: *mut MyPaintRectangles),
>;
#[doc = " Extends MyPaintSurface with support for spectral ops and multiple bounding boxes."]
#[doc = ""]
#[doc = " This extends the regular MyPaintSurface with three new"]
#[doc = " functions that support the use of spectral blending,"]
#[doc = " for drawing dabs and getting color, and additionally"]
#[doc = " supports using multiple invalidation rectangles when"]
#[doc = " finalizing drawing operations."]
#[doc = ""]
#[doc = " The interface functions for MyPaintSurface can be called"]
#[doc = " with instances of MyPaintSurface2 via the use of"]
#[doc = " mypaint_surface2_to_surface (or just casting). Concrete"]
#[doc = " implementations of MypaintSurface2 should support this."]
#[doc = ""]
#[doc = " @sa MyPaintSurface"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MyPaintSurface2 {
    #[doc = " Parent interface"]
    pub parent: MyPaintSurface,
    #[doc = " See #MyPaintSurfaceDrawDabFunction2"]
    pub draw_dab_pigment: MyPaintSurfaceDrawDabFunction2,
    #[doc = " See #MyPaintSurfaceGetColorFunction2"]
    pub get_color_pigment: MyPaintSurfaceGetColorFunction2,
    #[doc = " See #MyPaintSurfaceEndAtomicFunction2"]
    pub end_atomic_multi: MyPaintSurfaceEndAtomicFunction2,
}
#[test]
fn bindgen_test_layout_MyPaintSurface2() {
    assert_eq!(
        ::std::mem::size_of::<MyPaintSurface2>(),
        80usize,
        concat!("Size of: ", stringify!(MyPaintSurface2))
    );
    assert_eq!(
        ::std::mem::align_of::<MyPaintSurface2>(),
        8usize,
        concat!("Alignment of ", stringify!(MyPaintSurface2))
    );
    fn test_field_parent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<MyPaintSurface2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(MyPaintSurface2),
                "::",
                stringify!(parent)
            )
        );
    }
    test_field_parent();
    fn test_field_draw_dab_pigment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<MyPaintSurface2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).draw_dab_pigment) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(MyPaintSurface2),
                "::",
                stringify!(draw_dab_pigment)
            )
        );
    }
    test_field_draw_dab_pigment();
    fn test_field_get_color_pigment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<MyPaintSurface2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_color_pigment) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(MyPaintSurface2),
                "::",
                stringify!(get_color_pigment)
            )
        );
    }
    test_field_get_color_pigment();
    fn test_field_end_atomic_multi() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<MyPaintSurface2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).end_atomic_multi) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(MyPaintSurface2),
                "::",
                stringify!(end_atomic_multi)
            )
        );
    }
    test_field_end_atomic_multi();
}
extern "C" {
    #[doc = " Safely access the parent MyPaintSurface interface"]
    #[doc = ""]
    #[doc = " @memberof MyPaintSurface2"]
    pub fn mypaint_surface2_to_surface(self_: *mut MyPaintSurface2) -> *mut MyPaintSurface;
}
extern "C" {
    #[doc = " Call the surface's #get_color_pigment function."]
    #[doc = ""]
    #[doc = " See #MyPaintSurfaceGetColorFunction2 for details."]
    #[doc = ""]
    #[doc = " @memberof MyPaintSurface2"]
    pub fn mypaint_surface2_get_color(
        self_: *mut MyPaintSurface2,
        x: f32,
        y: f32,
        radius: f32,
        color_r: *mut f32,
        color_g: *mut f32,
        color_b: *mut f32,
        color_a: *mut f32,
        paint: f32,
    );
}
extern "C" {
    #[doc = " Call the surface's #end_atomic_multi function."]
    #[doc = ""]
    #[doc = " See #MyPaintSurfaceEndAtomicFunction2 for details."]
    #[doc = ""]
    #[doc = " @memberof MyPaintSurface2"]
    pub fn mypaint_surface2_end_atomic(self_: *mut MyPaintSurface2, roi: *mut MyPaintRectangles);
}
extern "C" {
    #[doc = " Call the surface's #draw_dab_pigment function."]
    #[doc = ""]
    #[doc = " See #MyPaintSurfaceDrawDabFunction2 for details."]
    #[doc = ""]
    #[doc = " @memberof MyPaintSurface2"]
    pub fn mypaint_surface2_draw_dab(
        self_: *mut MyPaintSurface2,
        x: f32,
        y: f32,
        radius: f32,
        color_r: f32,
        color_g: f32,
        color_b: f32,
        opaque: f32,
        hardness: f32,
        alpha_eraser: f32,
        aspect_ratio: f32,
        angle: f32,
        lock_alpha: f32,
        colorize: f32,
        posterize: f32,
        posterize_num: f32,
        paint: f32,
    ) -> ::std::os::raw::c_int;
}
pub const MyPaintBrushInput_MYPAINT_BRUSH_INPUT_PRESSURE: MyPaintBrushInput = 0;
pub const MyPaintBrushInput_MYPAINT_BRUSH_INPUT_SPEED1: MyPaintBrushInput = 1;
pub const MyPaintBrushInput_MYPAINT_BRUSH_INPUT_SPEED2: MyPaintBrushInput = 2;
pub const MyPaintBrushInput_MYPAINT_BRUSH_INPUT_RANDOM: MyPaintBrushInput = 3;
pub const MyPaintBrushInput_MYPAINT_BRUSH_INPUT_STROKE: MyPaintBrushInput = 4;
pub const MyPaintBrushInput_MYPAINT_BRUSH_INPUT_DIRECTION: MyPaintBrushInput = 5;
pub const MyPaintBrushInput_MYPAINT_BRUSH_INPUT_TILT_DECLINATION: MyPaintBrushInput = 6;
pub const MyPaintBrushInput_MYPAINT_BRUSH_INPUT_TILT_ASCENSION: MyPaintBrushInput = 7;
pub const MyPaintBrushInput_MYPAINT_BRUSH_INPUT_CUSTOM: MyPaintBrushInput = 8;
pub const MyPaintBrushInput_MYPAINT_BRUSH_INPUT_DIRECTION_ANGLE: MyPaintBrushInput = 9;
pub const MyPaintBrushInput_MYPAINT_BRUSH_INPUT_ATTACK_ANGLE: MyPaintBrushInput = 10;
pub const MyPaintBrushInput_MYPAINT_BRUSH_INPUT_TILT_DECLINATIONX: MyPaintBrushInput = 11;
pub const MyPaintBrushInput_MYPAINT_BRUSH_INPUT_TILT_DECLINATIONY: MyPaintBrushInput = 12;
pub const MyPaintBrushInput_MYPAINT_BRUSH_INPUT_GRIDMAP_X: MyPaintBrushInput = 13;
pub const MyPaintBrushInput_MYPAINT_BRUSH_INPUT_GRIDMAP_Y: MyPaintBrushInput = 14;
pub const MyPaintBrushInput_MYPAINT_BRUSH_INPUT_VIEWZOOM: MyPaintBrushInput = 15;
pub const MyPaintBrushInput_MYPAINT_BRUSH_INPUT_BARREL_ROTATION: MyPaintBrushInput = 16;
pub const MyPaintBrushInput_MYPAINT_BRUSH_INPUT_BRUSH_RADIUS: MyPaintBrushInput = 17;
pub const MyPaintBrushInput_MYPAINT_BRUSH_INPUTS_COUNT: MyPaintBrushInput = 18;
pub type MyPaintBrushInput = ::std::os::raw::c_uint;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_OPAQUE: MyPaintBrushSetting = 0;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_OPAQUE_MULTIPLY: MyPaintBrushSetting = 1;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_OPAQUE_LINEARIZE: MyPaintBrushSetting = 2;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_RADIUS_LOGARITHMIC: MyPaintBrushSetting = 3;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_HARDNESS: MyPaintBrushSetting = 4;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_ANTI_ALIASING: MyPaintBrushSetting = 5;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_DABS_PER_BASIC_RADIUS: MyPaintBrushSetting = 6;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_DABS_PER_ACTUAL_RADIUS: MyPaintBrushSetting = 7;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_DABS_PER_SECOND: MyPaintBrushSetting = 8;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_RADIUS_BY_RANDOM: MyPaintBrushSetting = 9;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_SPEED1_SLOWNESS: MyPaintBrushSetting = 10;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_SPEED2_SLOWNESS: MyPaintBrushSetting = 11;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_SPEED1_GAMMA: MyPaintBrushSetting = 12;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_SPEED2_GAMMA: MyPaintBrushSetting = 13;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_OFFSET_BY_RANDOM: MyPaintBrushSetting = 14;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_OFFSET_BY_SPEED: MyPaintBrushSetting = 15;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_OFFSET_BY_SPEED_SLOWNESS: MyPaintBrushSetting =
    16;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_SLOW_TRACKING: MyPaintBrushSetting = 17;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_SLOW_TRACKING_PER_DAB: MyPaintBrushSetting = 18;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_TRACKING_NOISE: MyPaintBrushSetting = 19;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_COLOR_H: MyPaintBrushSetting = 20;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_COLOR_S: MyPaintBrushSetting = 21;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_COLOR_V: MyPaintBrushSetting = 22;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_RESTORE_COLOR: MyPaintBrushSetting = 23;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_CHANGE_COLOR_H: MyPaintBrushSetting = 24;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_CHANGE_COLOR_L: MyPaintBrushSetting = 25;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_CHANGE_COLOR_HSL_S: MyPaintBrushSetting = 26;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_CHANGE_COLOR_V: MyPaintBrushSetting = 27;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_CHANGE_COLOR_HSV_S: MyPaintBrushSetting = 28;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_SMUDGE: MyPaintBrushSetting = 29;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_SMUDGE_LENGTH: MyPaintBrushSetting = 30;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_SMUDGE_RADIUS_LOG: MyPaintBrushSetting = 31;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_ERASER: MyPaintBrushSetting = 32;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_STROKE_THRESHOLD: MyPaintBrushSetting = 33;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_STROKE_DURATION_LOGARITHMIC:
    MyPaintBrushSetting = 34;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_STROKE_HOLDTIME: MyPaintBrushSetting = 35;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_CUSTOM_INPUT: MyPaintBrushSetting = 36;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_CUSTOM_INPUT_SLOWNESS: MyPaintBrushSetting = 37;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_ELLIPTICAL_DAB_RATIO: MyPaintBrushSetting = 38;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_ELLIPTICAL_DAB_ANGLE: MyPaintBrushSetting = 39;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_DIRECTION_FILTER: MyPaintBrushSetting = 40;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_LOCK_ALPHA: MyPaintBrushSetting = 41;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_COLORIZE: MyPaintBrushSetting = 42;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_SNAP_TO_PIXEL: MyPaintBrushSetting = 43;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_PRESSURE_GAIN_LOG: MyPaintBrushSetting = 44;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_GRIDMAP_SCALE: MyPaintBrushSetting = 45;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_GRIDMAP_SCALE_X: MyPaintBrushSetting = 46;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_GRIDMAP_SCALE_Y: MyPaintBrushSetting = 47;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_SMUDGE_LENGTH_LOG: MyPaintBrushSetting = 48;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_SMUDGE_BUCKET: MyPaintBrushSetting = 49;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_SMUDGE_TRANSPARENCY: MyPaintBrushSetting = 50;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_OFFSET_Y: MyPaintBrushSetting = 51;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_OFFSET_X: MyPaintBrushSetting = 52;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_OFFSET_ANGLE: MyPaintBrushSetting = 53;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_OFFSET_ANGLE_ASC: MyPaintBrushSetting = 54;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_OFFSET_ANGLE_VIEW: MyPaintBrushSetting = 55;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_OFFSET_ANGLE_2: MyPaintBrushSetting = 56;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_OFFSET_ANGLE_2_ASC: MyPaintBrushSetting = 57;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_OFFSET_ANGLE_2_VIEW: MyPaintBrushSetting = 58;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_OFFSET_ANGLE_ADJ: MyPaintBrushSetting = 59;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_OFFSET_MULTIPLIER: MyPaintBrushSetting = 60;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_POSTERIZE: MyPaintBrushSetting = 61;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_POSTERIZE_NUM: MyPaintBrushSetting = 62;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTING_PAINT_MODE: MyPaintBrushSetting = 63;
pub const MyPaintBrushSetting_MYPAINT_BRUSH_SETTINGS_COUNT: MyPaintBrushSetting = 64;
pub type MyPaintBrushSetting = ::std::os::raw::c_uint;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_X: MyPaintBrushState = 0;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_Y: MyPaintBrushState = 1;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_PRESSURE: MyPaintBrushState = 2;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_PARTIAL_DABS: MyPaintBrushState = 3;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_ACTUAL_RADIUS: MyPaintBrushState = 4;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_SMUDGE_RA: MyPaintBrushState = 5;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_SMUDGE_GA: MyPaintBrushState = 6;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_SMUDGE_BA: MyPaintBrushState = 7;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_SMUDGE_A: MyPaintBrushState = 8;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_LAST_GETCOLOR_R: MyPaintBrushState = 9;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_LAST_GETCOLOR_G: MyPaintBrushState = 10;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_LAST_GETCOLOR_B: MyPaintBrushState = 11;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_LAST_GETCOLOR_A: MyPaintBrushState = 12;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_LAST_GETCOLOR_RECENTNESS: MyPaintBrushState = 13;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_ACTUAL_X: MyPaintBrushState = 14;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_ACTUAL_Y: MyPaintBrushState = 15;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_NORM_DX_SLOW: MyPaintBrushState = 16;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_NORM_DY_SLOW: MyPaintBrushState = 17;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_NORM_SPEED1_SLOW: MyPaintBrushState = 18;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_NORM_SPEED2_SLOW: MyPaintBrushState = 19;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_STROKE: MyPaintBrushState = 20;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_STROKE_STARTED: MyPaintBrushState = 21;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_CUSTOM_INPUT: MyPaintBrushState = 22;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_RNG_SEED: MyPaintBrushState = 23;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_ACTUAL_ELLIPTICAL_DAB_RATIO: MyPaintBrushState = 24;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_ACTUAL_ELLIPTICAL_DAB_ANGLE: MyPaintBrushState = 25;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_DIRECTION_DX: MyPaintBrushState = 26;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_DIRECTION_DY: MyPaintBrushState = 27;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_DECLINATION: MyPaintBrushState = 28;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_ASCENSION: MyPaintBrushState = 29;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_VIEWZOOM: MyPaintBrushState = 30;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_VIEWROTATION: MyPaintBrushState = 31;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_DIRECTION_ANGLE_DX: MyPaintBrushState = 32;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_DIRECTION_ANGLE_DY: MyPaintBrushState = 33;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_ATTACK_ANGLE: MyPaintBrushState = 34;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_FLIP: MyPaintBrushState = 35;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_GRIDMAP_X: MyPaintBrushState = 36;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_GRIDMAP_Y: MyPaintBrushState = 37;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_DECLINATIONX: MyPaintBrushState = 38;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_DECLINATIONY: MyPaintBrushState = 39;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_DABS_PER_BASIC_RADIUS: MyPaintBrushState = 40;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_DABS_PER_ACTUAL_RADIUS: MyPaintBrushState = 41;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_DABS_PER_SECOND: MyPaintBrushState = 42;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATE_BARREL_ROTATION: MyPaintBrushState = 43;
pub const MyPaintBrushState_MYPAINT_BRUSH_STATES_COUNT: MyPaintBrushState = 44;
pub type MyPaintBrushState = ::std::os::raw::c_uint;
#[doc = " @brief Holds information about a single ::MyPaintBrushSetting"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MyPaintBrushSettingInfo {
    #[doc = " Canonical name - uniquely identifies the setting"]
    pub cname: *const gchar,
    #[doc = " Display name - descriptive name of the setting"]
    #[doc = ""]
    #[doc = " @sa mypaint_brush_setting_info_get_name"]
    pub name: *const gchar,
    #[doc = " Indicates whether the setting supports dynamics or not"]
    pub constant: gboolean,
    #[doc = " Mininmum base value"]
    pub min: f32,
    #[doc = " Default base value"]
    pub def: f32,
    #[doc = " Maximum base value"]
    pub max: f32,
    #[doc = " Tooltip - description of the setting"]
    #[doc = ""]
    #[doc = " @sa mypaint_brush_setting_info_get_tooltip"]
    pub tooltip: *const gchar,
}
#[test]
fn bindgen_test_layout_MyPaintBrushSettingInfo() {
    assert_eq!(
        ::std::mem::size_of::<MyPaintBrushSettingInfo>(),
        40usize,
        concat!("Size of: ", stringify!(MyPaintBrushSettingInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<MyPaintBrushSettingInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(MyPaintBrushSettingInfo))
    );
    fn test_field_cname() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<MyPaintBrushSettingInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cname) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(MyPaintBrushSettingInfo),
                "::",
                stringify!(cname)
            )
        );
    }
    test_field_cname();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<MyPaintBrushSettingInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(MyPaintBrushSettingInfo),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_constant() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<MyPaintBrushSettingInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).constant) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(MyPaintBrushSettingInfo),
                "::",
                stringify!(constant)
            )
        );
    }
    test_field_constant();
    fn test_field_min() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<MyPaintBrushSettingInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).min) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(MyPaintBrushSettingInfo),
                "::",
                stringify!(min)
            )
        );
    }
    test_field_min();
    fn test_field_def() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<MyPaintBrushSettingInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).def) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(MyPaintBrushSettingInfo),
                "::",
                stringify!(def)
            )
        );
    }
    test_field_def();
    fn test_field_max() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<MyPaintBrushSettingInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(MyPaintBrushSettingInfo),
                "::",
                stringify!(max)
            )
        );
    }
    test_field_max();
    fn test_field_tooltip() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<MyPaintBrushSettingInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tooltip) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(MyPaintBrushSettingInfo),
                "::",
                stringify!(tooltip)
            )
        );
    }
    test_field_tooltip();
}
extern "C" {
    #[doc = " @brief Get a pointer to the constant info struct for the given setting id."]
    #[doc = ""]
    #[doc = " @param id The ::MyPaintBrushSetting whose information will be returned."]
    #[doc = ""]
    #[doc = " @memberof MyPaintBrushSettingInfo"]
    pub fn mypaint_brush_setting_info(id: MyPaintBrushSetting) -> *const MyPaintBrushSettingInfo;
}
extern "C" {
    #[doc = " @brief Get the translated display name for the given setting."]
    #[doc = ""]
    #[doc = " @param self pointer to the settings info struct whose translated name will be returned."]
    #[doc = " @returns the translated display name, or the original display name if no translation"]
    #[doc = " exists for the active locale."]
    #[doc = " @memberof MyPaintBrushSettingInfo"]
    pub fn mypaint_brush_setting_info_get_name(
        self_: *const MyPaintBrushSettingInfo,
    ) -> *const gchar;
}
extern "C" {
    #[doc = " @brief Get the translated tooltip for the given setting"]
    #[doc = ""]
    #[doc = " @param self settings info object whose translated tooltip will be returned."]
    #[doc = " @returns the translated tooltip, or the original tooltip if no translation"]
    #[doc = " exists for the active locale."]
    #[doc = " @memberof MyPaintBrushSettingInfo"]
    pub fn mypaint_brush_setting_info_get_tooltip(
        self_: *const MyPaintBrushSettingInfo,
    ) -> *const gchar;
}
extern "C" {
    #[doc = " @brief Get the ::MyPaintBrushSetting id matching the given canonical name."]
    #[doc = ""]
    #[doc = " If the given char sequence is not a canonical name of a setting, -1 is returned."]
    #[doc = ""]
    #[doc = " @param cname the canonical name for the setting id to retrieve"]
    #[doc = " @returns The id whose corresponding \\ref MyPaintBrushSettingInfo::cname"]
    #[doc = " matches __cname__, or -1 if __cname__ is not a valid canonical name."]
    #[doc = ""]
    #[doc = " @memberof MyPaintBrushSettingInfo"]
    pub fn mypaint_brush_setting_from_cname(
        cname: *const ::std::os::raw::c_char,
    ) -> MyPaintBrushSetting;
}
#[doc = " @brief Holds information about a single @ref MyPaintBrushInput"]
#[doc = ""]
#[doc = " Like MyPaintBrushSettingInfo, these structs hold information"]
#[doc = " about canonical names, display names and tooltips. The remaining"]
#[doc = " data should be used to limit how the inputs are mapped to settings."]
#[doc = ""]
#[doc = " The __min__ and __max__ values in MyPaintBrushSettingInfo define limits"]
#[doc = " on the range that an input should be mapped _to_ for a setting."]
#[doc = " The __hard/soft_min/max__ values in this struct define limits on the"]
#[doc = " input range for mappings _from_ an input."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MyPaintBrushInputInfo {
    #[doc = " Canonical name - uniquely identifies the input"]
    pub cname: *const gchar,
    #[doc = " Hard lower limit of the input's range"]
    #[doc = ""]
    #[doc = " A value of -FLT_MAX should be interpreted as \"undefined\", and"]
    #[doc = " a constant minimum should be used instead (MyPaint uses -20)."]
    pub hard_min: f32,
    #[doc = " Default lower limit of the input's range"]
    pub soft_min: f32,
    #[doc = " Expected normal value for the input - only used as a reference"]
    #[doc = " when creating mappings."]
    pub normal: f32,
    #[doc = " Default upper limit of the input's range"]
    pub soft_max: f32,
    #[doc = " Hard upper limit of the input's range"]
    #[doc = ""]
    #[doc = " A value of FLT_MAX should be interpreted as \"undefined\", and"]
    #[doc = " a constant maximum should be used instead (MyPaint uses 20)."]
    pub hard_max: f32,
    #[doc = " Display name - descriptive name of the input"]
    #[doc = ""]
    #[doc = " @sa mypaint_brush_input_info_get_name"]
    pub name: *const gchar,
    #[doc = " Tooltip - brief description of the input."]
    #[doc = ""]
    #[doc = " @sa mypaint_brush_input_info_get_tooltip"]
    pub tooltip: *const gchar,
}
#[test]
fn bindgen_test_layout_MyPaintBrushInputInfo() {
    assert_eq!(
        ::std::mem::size_of::<MyPaintBrushInputInfo>(),
        48usize,
        concat!("Size of: ", stringify!(MyPaintBrushInputInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<MyPaintBrushInputInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(MyPaintBrushInputInfo))
    );
    fn test_field_cname() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<MyPaintBrushInputInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cname) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(MyPaintBrushInputInfo),
                "::",
                stringify!(cname)
            )
        );
    }
    test_field_cname();
    fn test_field_hard_min() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<MyPaintBrushInputInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hard_min) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(MyPaintBrushInputInfo),
                "::",
                stringify!(hard_min)
            )
        );
    }
    test_field_hard_min();
    fn test_field_soft_min() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<MyPaintBrushInputInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).soft_min) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(MyPaintBrushInputInfo),
                "::",
                stringify!(soft_min)
            )
        );
    }
    test_field_soft_min();
    fn test_field_normal() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<MyPaintBrushInputInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).normal) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(MyPaintBrushInputInfo),
                "::",
                stringify!(normal)
            )
        );
    }
    test_field_normal();
    fn test_field_soft_max() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<MyPaintBrushInputInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).soft_max) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(MyPaintBrushInputInfo),
                "::",
                stringify!(soft_max)
            )
        );
    }
    test_field_soft_max();
    fn test_field_hard_max() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<MyPaintBrushInputInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hard_max) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(MyPaintBrushInputInfo),
                "::",
                stringify!(hard_max)
            )
        );
    }
    test_field_hard_max();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<MyPaintBrushInputInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(MyPaintBrushInputInfo),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_tooltip() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<MyPaintBrushInputInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tooltip) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(MyPaintBrushInputInfo),
                "::",
                stringify!(tooltip)
            )
        );
    }
    test_field_tooltip();
}
extern "C" {
    #[doc = " @brief Get a pointer to the constant info struct for the given input id."]
    #[doc = ""]
    #[doc = " @param id The ::MyPaintBrushInput whose information will be returned."]
    #[doc = ""]
    #[doc = " @memberof MyPaintBrushInputInfo"]
    pub fn mypaint_brush_input_info(id: MyPaintBrushInput) -> *const MyPaintBrushInputInfo;
}
extern "C" {
    #[doc = " @brief Get the translated display name for the given input."]
    #[doc = ""]
    #[doc = " @param self pointer to the input info struct whose translated name will be returned."]
    #[doc = " @returns the translated display name, or the original display name if no translation"]
    #[doc = " exists for the active locale."]
    #[doc = " @memberof MyPaintBrushInputInfo"]
    pub fn mypaint_brush_input_info_get_name(self_: *const MyPaintBrushInputInfo) -> *const gchar;
}
extern "C" {
    #[doc = " @brief Get the translated display name for the given input."]
    #[doc = ""]
    #[doc = " @param self pointer to the input info struct whose translated name will be returned."]
    #[doc = " @returns the translated tooltip, or the original tooltip if no translation"]
    #[doc = " exists for the active locale."]
    #[doc = " @memberof MyPaintBrushInputInfo"]
    pub fn mypaint_brush_input_info_get_tooltip(
        self_: *const MyPaintBrushInputInfo,
    ) -> *const gchar;
}
extern "C" {
    #[doc = " @brief Get the ::MyPaintBrushInput id matching the given canonical name."]
    #[doc = ""]
    #[doc = " If the given input is not a canonical name of an input, -1 is returned."]
    #[doc = ""]
    #[doc = " @param cname the canonical name for the input id to retrieve"]
    #[doc = " @returns The id whose corresponding \\ref MyPaintBrushInputInfo::cname"]
    #[doc = " matches __cname__, or -1 if __cname__ is not a valid canonical name."]
    #[doc = ""]
    #[doc = " @memberof MyPaintBrushInputInfo"]
    pub fn mypaint_brush_input_from_cname(
        cname: *const ::std::os::raw::c_char,
    ) -> MyPaintBrushInput;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MyPaintBrush {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Create a new brush"]
    #[doc = ""]
    #[doc = " @memberof MyPaintBrush"]
    pub fn mypaint_brush_new() -> *mut MyPaintBrush;
}
extern "C" {
    #[doc = " Create a new brush with smudge buckets enabled."]
    #[doc = ""]
    #[doc = " This kind of brush is required to make use of the"]
    #[doc = " @ref MYPAINT_BRUSH_SETTING_SMUDGE_BUCKET setting."]
    #[doc = ""]
    #[doc = " Smudge buckets are an array of smudge data states, used to allow"]
    #[doc = " dabs in offset locations to use smudge data consistent with their location,"]
    #[doc = " when those location-sequential dabs are not actually drawn consecutively."]
    #[doc = ""]
    #[doc = " @memberof MyPaintBrush"]
    pub fn mypaint_brush_new_with_buckets(
        num_smudge_buckets: ::std::os::raw::c_int,
    ) -> *mut MyPaintBrush;
}
extern "C" {
    #[doc = " Decrease the reference count by one, destroying the brush if it reaches 0."]
    #[doc = ""]
    #[doc = " Not safe to call with NULL!"]
    #[doc = ""]
    #[doc = " @memberof MyPaintBrush"]
    pub fn mypaint_brush_unref(self_: *mut MyPaintBrush);
}
extern "C" {
    #[doc = " Increase the reference count by one."]
    #[doc = ""]
    #[doc = " Not safe to call with NULL!"]
    #[doc = ""]
    #[doc = " @memberof MyPaintBrush"]
    pub fn mypaint_brush_ref(self_: *mut MyPaintBrush);
}
extern "C" {
    #[doc = " Request a reset if the brush state."]
    #[doc = ""]
    #[doc = " The request is not acted on immediately, but only in subsequent calls"]
    #[doc = " to mypaint_brush_stroke_to and/or mypaint_brush_stroke_to2."]
    #[doc = ""]
    #[doc = " Only state values (including smudge buckets, if used) are affected upon reset,"]
    #[doc = " not settings/mappings."]
    #[doc = ""]
    #[doc = " @memberof MyPaintBrush"]
    pub fn mypaint_brush_reset(self_: *mut MyPaintBrush);
}
extern "C" {
    #[doc = " Start a new stroke."]
    #[doc = ""]
    #[doc = " Reset the stroke time parameters."]
    #[doc = " Not directly related to mypaint_stroke_to (and varieties), calling"]
    #[doc = " the former does not require calling mypaint_brush_new_stroke."]
    #[doc = ""]
    #[doc = " @memberof MyPaintBrush"]
    pub fn mypaint_brush_new_stroke(self_: *mut MyPaintBrush);
}
extern "C" {
    #[doc = " Use the brush to draw a stroke segment on a MyPaintSurface"]
    #[doc = ""]
    #[doc = " @memberof MyPaintBrush"]
    pub fn mypaint_brush_stroke_to(
        self_: *mut MyPaintBrush,
        surface: *mut MyPaintSurface,
        x: f32,
        y: f32,
        pressure: f32,
        xtilt: f32,
        ytilt: f32,
        dtime: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Use the brush to draw a stroke segment on a MyPaintSurface2"]
    #[doc = ""]
    #[doc = " @memberof MyPaintBrush"]
    pub fn mypaint_brush_stroke_to_2(
        self_: *mut MyPaintBrush,
        surface: *mut MyPaintSurface2,
        x: f32,
        y: f32,
        pressure: f32,
        xtilt: f32,
        ytilt: f32,
        dtime: f64,
        viewzoom: f32,
        viewrotation: f32,
        barrel_rotation: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Same as mypaint_brush_stroke_to_2, but using linear sRGB for color dynamics."]
    #[doc = ""]
    #[doc = " The settings that are handled differently from the other call are:"]
    #[doc = ""]
    #[doc = " - ::MYPAINT_BRUSH_SETTING_CHANGE_COLOR_H"]
    #[doc = " - ::MYPAINT_BRUSH_SETTING_CHANGE_COLOR_L"]
    #[doc = " - ::MYPAINT_BRUSH_SETTING_CHANGE_COLOR_HSL_S"]
    #[doc = " - ::MYPAINT_BRUSH_SETTING_CHANGE_COLOR_V"]
    #[doc = " - ::MYPAINT_BRUSH_SETTING_CHANGE_COLOR_HSV_S"]
    #[doc = ""]
    #[doc = " @memberof MyPaintBrush"]
    pub fn mypaint_brush_stroke_to_2_linearsRGB(
        self_: *mut MyPaintBrush,
        surface: *mut MyPaintSurface2,
        x: f32,
        y: f32,
        pressure: f32,
        xtilt: f32,
        ytilt: f32,
        dtime: f64,
        viewzoom: f32,
        viewrotation: f32,
        barrel_rotation: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the base value of a brush setting."]
    #[doc = ""]
    #[doc = " @memberof MyPaintBrush"]
    pub fn mypaint_brush_set_base_value(
        self_: *mut MyPaintBrush,
        id: MyPaintBrushSetting,
        value: f32,
    );
}
extern "C" {
    #[doc = " Get the base value of a brush setting."]
    #[doc = ""]
    #[doc = " @memberof MyPaintBrush"]
    pub fn mypaint_brush_get_base_value(self_: *mut MyPaintBrush, id: MyPaintBrushSetting) -> f32;
}
extern "C" {
    #[doc = " Check if there are no dynamics/mappings for a brush setting."]
    #[doc = ""]
    #[doc = " This will return FALSE if any input mappings exist for the setting with"]
    #[doc = " the given id, even if all such mappings themselves are constant."]
    #[doc = ""]
    #[doc = " @memberof MyPaintBrush"]
    pub fn mypaint_brush_is_constant(self_: *mut MyPaintBrush, id: MyPaintBrushSetting)
        -> gboolean;
}
extern "C" {
    #[doc = " Get the number of input mappings for a brush setting."]
    #[doc = ""]
    #[doc = " @memberof MyPaintBrush"]
    pub fn mypaint_brush_get_inputs_used_n(
        self_: *mut MyPaintBrush,
        id: MyPaintBrushSetting,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the number of points in an input mapping for a brush setting."]
    #[doc = ""]
    #[doc = " @memberof MyPaintBrush"]
    pub fn mypaint_brush_set_mapping_n(
        self_: *mut MyPaintBrush,
        id: MyPaintBrushSetting,
        input: MyPaintBrushInput,
        n: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Get the number of points in an input mapping for a brush setting."]
    #[doc = ""]
    #[doc = " @memberof MyPaintBrush"]
    pub fn mypaint_brush_get_mapping_n(
        self_: *mut MyPaintBrush,
        id: MyPaintBrushSetting,
        input: MyPaintBrushInput,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the coordinates of a point in an input mapping for a brush setting."]
    #[doc = ""]
    #[doc = " @memberof MyPaintBrush"]
    pub fn mypaint_brush_set_mapping_point(
        self_: *mut MyPaintBrush,
        id: MyPaintBrushSetting,
        input: MyPaintBrushInput,
        index: ::std::os::raw::c_int,
        x: f32,
        y: f32,
    );
}
extern "C" {
    #[doc = " Get the coordinates of a point in an input mapping for a brush setting."]
    #[doc = ""]
    #[doc = " @memberof MyPaintBrush"]
    pub fn mypaint_brush_get_mapping_point(
        self_: *mut MyPaintBrush,
        id: MyPaintBrushSetting,
        input: MyPaintBrushInput,
        index: ::std::os::raw::c_int,
        x: *mut f32,
        y: *mut f32,
    );
}
extern "C" {
    #[doc = " Get the value of a brush state."]
    #[doc = ""]
    #[doc = " @memberof MyPaintBrush"]
    pub fn mypaint_brush_get_state(self_: *mut MyPaintBrush, i: MyPaintBrushState) -> f32;
}
extern "C" {
    #[doc = " Set the value of a brush state."]
    #[doc = ""]
    #[doc = " @memberof MyPaintBrush"]
    pub fn mypaint_brush_set_state(self_: *mut MyPaintBrush, i: MyPaintBrushState, value: f32);
}
extern "C" {
    #[doc = " Get the total time recorded since the last call to mypaint_brush_reset"]
    #[doc = ""]
    #[doc = " @memberof MyPaintBrush"]
    pub fn mypaint_brush_get_total_stroke_painting_time(self_: *mut MyPaintBrush) -> f64;
}
extern "C" {
    #[doc = " Enable/Disable debug printouts"]
    #[doc = ""]
    #[doc = " @memberof MyPaintBrush"]
    pub fn mypaint_brush_set_print_inputs(self_: *mut MyPaintBrush, enabled: gboolean);
}
extern "C" {
    #[doc = " Initialize a brush with default values for all settings."]
    #[doc = ""]
    #[doc = " @memberof MyPaintBrush"]
    pub fn mypaint_brush_from_defaults(self_: *mut MyPaintBrush);
}
extern "C" {
    #[doc = " Initialize a brush from a JSON string."]
    #[doc = ""]
    #[doc = " @memberof MyPaintBrush"]
    pub fn mypaint_brush_from_string(
        self_: *mut MyPaintBrush,
        string: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MyPaintMapping {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Create new mappings for a set number of inputs."]
    #[doc = ""]
    #[doc = " @memberof MyPaintMapping"]
    pub fn mypaint_mapping_new(inputs_: ::std::os::raw::c_int) -> *mut MyPaintMapping;
}
extern "C" {
    #[doc = " Free an instance of MyPaintMapping"]
    #[doc = ""]
    #[doc = " @memberof MyPaintMapping"]
    pub fn mypaint_mapping_free(self_: *mut MyPaintMapping);
}
extern "C" {
    #[doc = " Get the base value of the mappings."]
    #[doc = ""]
    #[doc = " @memberof MyPaintMapping"]
    pub fn mypaint_mapping_get_base_value(self_: *mut MyPaintMapping) -> f32;
}
extern "C" {
    #[doc = " Set the base value of the mappings."]
    #[doc = ""]
    #[doc = " @memberof MyPaintMapping"]
    pub fn mypaint_mapping_set_base_value(self_: *mut MyPaintMapping, value: f32);
}
extern "C" {
    #[doc = " Set the number of control points used for the input"]
    #[doc = ""]
    #[doc = " @memberof MyPaintMapping"]
    pub fn mypaint_mapping_set_n(
        self_: *mut MyPaintMapping,
        input: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Get the number of control points used for the input"]
    #[doc = ""]
    #[doc = " @memberof MyPaintMapping"]
    pub fn mypaint_mapping_get_n(
        self_: *mut MyPaintMapping,
        input: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the x, y coordinates for a control point."]
    #[doc = ""]
    #[doc = " @memberof MyPaintMapping"]
    pub fn mypaint_mapping_set_point(
        self_: *mut MyPaintMapping,
        input: ::std::os::raw::c_int,
        index: ::std::os::raw::c_int,
        x: f32,
        y: f32,
    );
}
extern "C" {
    #[doc = " Get the x, y coordinates for a control point."]
    #[doc = ""]
    #[doc = " @memberof MyPaintMapping"]
    pub fn mypaint_mapping_get_point(
        self_: *mut MyPaintMapping,
        input: ::std::os::raw::c_int,
        index: ::std::os::raw::c_int,
        x: *mut f32,
        y: *mut f32,
    );
}
extern "C" {
    #[doc = " Returns TRUE if none of the mappings are used."]
    #[doc = ""]
    #[doc = " @memberof MyPaintMapping"]
    #[doc = ""]
    #[doc = " @sa mypaint_brush_is_constant"]
    pub fn mypaint_mapping_is_constant(self_: *mut MyPaintMapping) -> gboolean;
}
extern "C" {
    #[doc = " Get the number of inputs that have control points."]
    #[doc = ""]
    #[doc = " @memberof MyPaintMapping"]
    pub fn mypaint_mapping_get_inputs_used_n(self_: *mut MyPaintMapping) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Calculate the output of the mapping, given an input value for each mapping."]
    #[doc = ""]
    #[doc = " @memberof MyPaintMapping"]
    pub fn mypaint_mapping_calculate(self_: *mut MyPaintMapping, data: *mut f32) -> f32;
}
extern "C" {
    #[doc = " Calculate the output for a single-input mapping."]
    #[doc = ""]
    #[doc = " @memberof MyPaintMapping"]
    pub fn mypaint_mapping_calculate_single_input(self_: *mut MyPaintMapping, input: f32) -> f32;
}
